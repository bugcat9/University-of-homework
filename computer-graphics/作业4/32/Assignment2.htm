<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<!-- saved from url=(0079)http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment1/ --><HTML><HEAD><TITLE>6.837 Assignment 1</TITLE>
<META http-equiv=Content-Type content="text/html; charset=iso-8859-1">
<META content="Microsoft FrontPage 5.0" name=GENERATOR></HEAD>
<BODY text=#000000 bgColor=#ffffff background=Assignment2.files/blbkgnd.gif>
<H1>Intro to Computer Graphics<BR>Assignment 2: Ray Casting</H1>
<P>In this assignment, you will implement a basic ray caster. This will be the 
basis of many future assignments, so proper code design is quite important. As 
seen in class, a ray caster sends a ray for each pixel and intersects it with 
all the objects in the scene. You will implement a ray caster for an 
orthographic camera (parallel rays) for sphere primitives. You will use a very 
basic shading model: the objects have a constant color. You will also implement 
a visualization mode to display the distance <EM>t</EM> of each pixel to the 
camera. 
<P>You will use object-oriented design to make your ray-caster flexible and 
extendable. A generic <TT>Object3D</TT> class will serve as the parent class for 
all 3D primitives. You will derive subclasses, such as <TT>Sphere</TT>, to 
implement specialized primitives. In later assignments, you will extend the set 
of primitives with planes and polygons. Similarly, this assignment requires the 
implementation of a general <TT>Camera</TT> class and an 
<TT>OrthographicCamera</TT> subclass. In the next assignment, you will also 
derive a general perspective camera. 
<P>We provide you with a <TT>Ray</TT> class and a <TT>Hit</TT> class to 
manipulate camera rays and their intersection points, and a skeleton 
<TT>Material</TT> class. 
<H3>Tasks</H3>
<UL>
  <P>
  <LI>Write a pure virtual <TT>Object3D</TT> class. It only provides the 
  specification for 3D primitives, and in particular the ability to be 
  intersected with a ray via the virtual method: <PRE>   virtual bool intersect(const Ray &amp;r, Hit &amp;h, float tmin) = 0;
</PRE>
  <P>Since this method is pure virtual for the <TT>Object3D</TT> class, the 
  prototype in the header file includes '<TT>= 0;</TT>'. Subclasses derived from 
  <TT>Object3D</TT> must implement this routine. An <TT>Object3D</TT> stores a 
  pointer to its <TT>Material</TT> type. For this assignment, materials are very 
  simple and consist of a single color. Your <TT>Object3D</TT> class must have: 
  <UL>
    <LI>a default constructor and destructor, 
    <LI>a pointer to a <TT>Material</TT> instance, and 
    <LI>a pure virtual intersection method. </LI></UL>
  <P>
  <P></P>
  <LI>Derive <TT>Sphere</TT>, a subclass of <TT>Object3D</TT>, that additionally 
  stores a center point and a radius. The <TT>Sphere</TT> constructor will be 
  given the center, radius, and pointer to a <TT>Material</TT> instance. The 
  <TT>Sphere</TT> class implements the virtual <TT>intersect</TT> method 
  mentioned above (but without the '<TT>= 0;</TT>'): <PRE>  virtual bool intersect(const Ray &amp;r, Hit &amp;h, float tmin);
</PRE>
  <P>With the <TT>intersect</TT> routine, we are looking for the closest 
  intersection along a <TT>Ray</TT>, parameterized by <EM>t</EM>. <TT>tmin</TT> 
  is used to restrict the range of intersection. If an intersection is found 
  such that <EM>t</EM> &gt; <TT>tmin</TT> and <EM>t</EM> is less than the value 
  of the intersection currently stored in the <TT>Hit</TT> data structure, 
  <TT>Hit</TT> is updated as necessary. Note that if the new intersection is 
  closer than the previous one, both <TT>t</TT> and <TT>Material</TT> must be 
  modified. It is important that your intersection routine verifies that 
  <EM>t</EM> &gt;= <TT>tmin</TT>. <TT>tmin</TT> depends on the type of camera 
  (see below) and is not modified by the intersection routine. 
  <P></P>
  <LI>Derive <TT>Group</TT>, also a subclass of <TT>Object3D</TT>, that stores 
  an array of pointers to <TT>Object3D</TT> instances. For example, it will be 
  used to store the entire 3D scene. You'll need to write the <TT>intersect</TT> 
  method of <TT>Group</TT> which loops through all these instances, calling 
  their intersection methods. The <TT>Group</TT> constructor should take as 
  input the number of objects under the group. The group should include a method 
  to add the objects: <PRE>   void addObject(int index, Object3D *obj); 
</PRE>
  <P></P>
  <LI>Write a pure virtual <TT>Camera</TT> class and subclass 
  <TT>OrthographicCamera</TT>. The <TT>Camera</TT> class has two pure virtual 
  methods: <PRE>   virtual Ray generateRay(Vec2f point) = 0;
   virtual float getTMin() const = 0;
</PRE>The first is used to generate rays for each screen-space coordinate, 
  described as a <TT>Vec2f</TT>. The direction of the rays generated by an 
  orthographic camera is always the same, but the origin varies. The 
  <TT>getTMin()</TT> method will be useful when tracing rays through the scene. 
  For an orthographic camera, rays always start at infinity, so <TT>tmin</TT> 
  will be a large negative value. However, in the next assignment you will 
  implement a perspective camera and the value of <TT>tmin</TT> will be zero to 
  correctly clip objects behind the viewpoint. 
  <P><IMG height=250 src="Assignment2.files/ortho.png" width=500> 
  <P>An orthographic camera is described by an orthonormal basis (one point and 
  three vectors) and an image size (one floating point). The constructor takes 
  as input the center of the image, the direction vector, an up vector, and the 
  image size. The input direction might not be a unit vector and must be 
  normalized. The input up vector might not be a unit vector <EM>or</EM> 
  perpendicular to the direction. It must be modified to be orthonormal to the 
  direction. The third basis vector, the horizontal vector of the image plane, 
  is deduced from the direction and the up vector (hint: remember vector algebra 
  and cross products). The origin of the rays generated by the camera for the 
  screen coordinates, which vary from <TT>(0,0) -&gt; (1,1)</TT>, should vary 
  from: <PRE>   center - (size*up)/2 - (size*horizontal)/2  -&gt;  center + (size*up)/2 + (size*horizontal)/2
</PRE>
  <P>The camera does not know about screen resolution. Image resolution should 
  be handled in your main loop. For non-square image ratios, just crop the 
  screen coordinates accordingly. 
  <P>
  <P></P>
  <LI>Use the input file parsing code provided to load the camera, background 
  color and objects of the scene. 
  <P></P>
  <LI>Write a main function that reads the scene (using the parsing code 
  provided), loops over the pixels in the image plane, generates a ray using 
  your <TT>OrthographicCamera</TT> class, intersects it with the high-level 
  <TT>Group</TT> that stores the objects of the scene, and writes the color of 
  the closest intersected object. 
  <P></P>
  <LI>Implement a second rendering style to visualize the depth <EM>t</EM> of 
  objects in the scene. Two input depth values specify the range of depth values 
  which should be mapped to shades of gray in the visualization. Depth values 
  outside this range are simply clamped. 
  <P></P>
  <LI>Extra credit: Write both the geometric and algebraic sphere intersection 
  methods, add cylinders and cones, fog based on distance to the image plane, 
  etc. </LI></UL>
<H3>Ray, Hit &amp; Material Classes</H3>We provide the <TT>Ray</TT>, 
<TT>Hit</TT> &amp; <TT>Material</TT> classes. A <TT>Ray</TT> is represented by 
its origin and direction vectors. The <TT>Hit</TT> class stores information 
about the closest intersection point, the value of the ray parameter <EM>t</EM> 
and a pointer to the <TT>Material</TT> of the object at the intersection. The 
<TT>Hit</TT> data structure must be initialized with a very large <EM>t</EM> 
value. It is modified by the intersection computation to store the new closest 
<EM>t</EM> and the <TT>Material</TT> of intersected object. For this assignment 
a <TT>Material</TT> stores just the diffuse color of the object. You will extend 
this class in future assignments. 
<UL>
  <LI><a href="Assignment2.files/ray.h">ray.h</a> 
  <LI><a href="Assignment2.files/hit.h">hit.h</a> 
  <LI><a href="Assignment2.files/material.h">material.h</a> 
  </LI></UL>
<H3>Parsing command line arguments &amp; input files</H3>Your program should 
take a number of command line arguments to specify the input file, output image 
size and output file. Make sure the examples below work, as this is how we will 
test your program. A simple scene file parser for this assignment is provided. 
The <TT>OrthographicCamera</TT>, <TT>Group</TT> and <TT>Sphere</TT> constructors 
and the <TT>Group::addObject</TT> method you will write are called from the 
parser. Look in the <TT>scene_parser.C</TT> file for details. 
<UL>
  <LI><a href="Assignment2.files/parse_code.txt">parse_code.txt</a> 

  <LI><a href="Assignment2.files/scene_parser.h">scene_parser.h</a> 

  <LI><a href="Assignment2.files/scene_parser.C">scene_parser.C</a> 
  </LI></UL>If you're interested, here's the <A 
href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/assignment1/grammar.html">scene 
description file grammar</A> used in this assignment. 
<H3>Hints</H3>
<UL>
  <LI>Use a small image size for faster debugging. <TT>64 x 64</TT> pixels is 
  usually enough to realize that something might be wrong. 
  <LI>As usual, don't hesitate to print as much information as needed for 
  debugging, such as the direction vector of the rays, the hit values, etc. 
  <LI>Use <TT>assert()</TT> to check function pre-conditions, array indices, 
  etc. See <TT>assert.h</TT>. 
  <LI>The "very large" negative and positive values for <EM>t</EM> used in the 
  <TT>Hit</TT> class and the <TT>intersect</TT> routine can simply be 
  initialized with large values relative to the camera position and scene 
  dimensions. However, to be more correct, you can use the positive and negative 
  values for infinity from the IEEE floating point standard (for extra credit). 
  </LI></UL>
<H3>Additional References</H3>
<UL>
  <LI><A href="http://www.irtc.org/">http://www.irtc.org/</A> 
  <LI><A 
  href="http://www.acm.org/tog/resources/RTNews/html/">http://www.acm.org/tog/resources/RTNews/html/</A> 

  <LI><A href="http://www.povray.org/">http://www.povray.org/</A> 
  <LI><A 
  href="http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace0.htm">http://www.siggraph.org/education/materials/HyperGraph/raytrace/rtrace0.htm</A> 

  <LI><A 
  href="http://www.siggraph.org/education/materials/HyperGraph/raytrace/rt_java/raytrace.html">http://www.siggraph.org/education/materials/HyperGraph/raytrace/rt_java/raytrace.html</A> 
  </LI></UL>
<H3>Input Files</H3>
<UL>
  <LI><a href="Assignment2.files/scene1_01.txt">scene1_01.txt</a> 

  <LI><a href="Assignment2.files/scene1_02.txt">scene1_02.txt</a> 

  <LI><a href="Assignment2.files/scene1_03.txt">scene1_03.txt</a> 

  <LI><a href="Assignment2.files/scene1_04.txt">scene1_04.txt</a> 

  <LI><a href="Assignment2.files/scene1_05.txt">scene1_05.txt</a> 

  <LI><a href="Assignment2.files/scene1_06.txt">scene1_06.txt</a> 

  <LI><a href="Assignment2.files/scene1_07.txt">scene1_07.txt</a> 
  </LI></UL>
<H3>Makefile for g++ on LINUX</H3>
<UL>
  <LI><a href="Assignment2.files/Makefile.txt">Makefile</a> 
  </LI></UL>
<H3>Sample Results</H3><PRE>raytracer -input scene1_01.txt -size 200 200 -output output1_01.tga -depth 9 10 depth1_01.tga
</PRE>
<P><IMG height=200 src="Assignment2.files/output1_01.png" width=200> <IMG 
height=200 src="Assignment2.files/depth1_01.png" width=200> 
<P><PRE>raytracer -input scene1_02.txt -size 200 200 -output output1_02.tga -depth 8 12 depth1_02.tga
</PRE>
<P><IMG height=200 src="Assignment2.files/output1_02.png" width=200> <IMG 
height=200 src="Assignment2.files/depth1_02.png" width=200> 
<P><PRE>raytracer -input scene1_03.txt -size 200 200 -output output1_03.tga -depth 8 12 depth1_03.tga
</PRE>
<P><IMG height=200 src="Assignment2.files/output1_03.png" width=200> <IMG 
height=200 src="Assignment2.files/depth1_03.png" width=200> 
<P><PRE>raytracer -input scene1_04.txt -size 200 200 -output output1_04.tga -depth 12 17 depth1_04.tga
</PRE>
<P><IMG height=200 src="Assignment2.files/output1_04.png" width=200> <IMG 
height=200 src="Assignment2.files/depth1_04.png" width=200> 
<P><PRE>raytracer -input scene1_05.txt -size 200 200 -output output1_05.tga -depth 14.5 19.5 depth1_05.tga
</PRE>
<P><IMG height=200 src="Assignment2.files/output1_05.png" width=200> <IMG 
height=200 src="Assignment2.files/depth1_05.png" width=200> 
<P><PRE>raytracer -input scene1_06.txt -size 200 200 -output output1_06.tga -depth 3 7 depth1_06.tga
</PRE>
<P><IMG height=200 src="Assignment2.files/output1_06.png" width=200> <IMG 
height=200 src="Assignment2.files/depth1_06.png" width=200> 
<P><PRE>raytracer -input scene1_07.txt -size 200 200 -output output1_07.tga -depth -2 2 depth1_07.tga
</PRE>
<P><IMG height=200 src="Assignment2.files/output1_07.png" width=200> <IMG 
height=200 src="Assignment2.files/depth1_07.png" width=200> 
<P>See the main <A 
href="http://groups.csail.mit.edu/graphics/classes/6.837/F04/assignments/index.html">Assignments 
Page</A> for submission information. 
<HR>
</BODY></HTML>